import { bindData, action } from './decorators'
import { State } from './state'
import { Action } from './action'
import { STATEX_ACTION_KEY } from '../@angular'

describe('bindData', () => {

  beforeEach(() => {
    State.next({ currentUser: { id: 'statex-user' } })
  })

  test('should update property of an object based on selection', async () => {
    const object = { user: undefined }
    bindData(object, 'user', state => state.currentUser)
    expect(object.user).toEqual({ id: 'statex-user' })
  })

  test('should call a function of an object based on a selection', async () => {
    const object = { user: jest.fn() }
    bindData(object, 'user', state => state.currentUser)
    expect(object.user).toHaveBeenCalledWith({ id: 'statex-user' })
  })

  test('should call setState function if defined', async () => {
    const object = { setState: jest.fn() }
    bindData(object, 'user', state => state.currentUser)
    expect(object.setState).toHaveBeenCalledWith({ user: { id: 'statex-user' } })
  })

})

describe('action', () => {

  beforeEach(() => {
    State.next({ currentUser: { id: 'statex-user' } })
  })

  test('should capture the action binding meta when action is passed as a parameter', async () => {
    const reducer = jest.fn()
    class SampleAction extends Action { }
    const store = { reducer }
    let actions = Reflect.getMetadata(STATEX_ACTION_KEY, store)
    expect(actions).toBeUndefined()
    store.reducer = action(SampleAction as any)(store, 'reducer', {})
    actions = Reflect.getMetadata(STATEX_ACTION_KEY, store)
    expect(Object.keys(actions)).toEqual(['reducer'])
  })

  test('should capture the action binding meta of more than one reducer', async () => {
    class SampleAction extends Action { }
    const store = { reducer1: undefined, reducer2: undefined }
    let actions = Reflect.getMetadata(STATEX_ACTION_KEY, store)
    expect(actions).toBeUndefined()
    store.reducer1 = action(SampleAction as any)(store, 'reducer1', {})
    store.reducer2 = action(SampleAction as any)(store, 'reducer2', {})
    actions = Reflect.getMetadata(STATEX_ACTION_KEY, store)
    expect(Object.keys(actions)).toEqual(['reducer1', 'reducer2'])
  })

  test('should capture the action binding meta when action is passed property type', async () => {
    const reducer = jest.fn()
    class SampleAction extends Action { }
    const store = { reducer }
    // Mocking the meta otherwise generated by typescript
    Reflect.defineMetadata('design:paramtypes', [undefined, SampleAction], store, 'reducer')
    store.reducer = action()(store, 'reducer', {})
    const actions = Reflect.getMetadata(STATEX_ACTION_KEY, store)
    expect(Object.keys(actions)).toEqual(['reducer'])
  })

  test('should throw an error if action is not defined for reducer', async () => {
    const reducer = jest.fn()
    class SampleAction extends Action { }
    const store = { reducer }
    expect(() => {
      store.reducer = action()(store, 'reducer', {})
    }).toThrowError()
  })

})